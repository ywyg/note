# NETTY

> Netty 是一个 NIO 客户端服务器框架，可以快速轻松地开发网络应用程序，例如协议服务器和客户端。它极大地简化和精简了 TCP 和 UDP 套接字服务器等网络编程。
>
> “快速而简单”并不意味着生成的应用程序会受到可维护性或性能问题的影响。Netty 是根据从许多协议（如 FTP、SMTP、HTTP 以及各种基于二进制和文本的遗留协议）的实现中获得的经验而精心设计的。结果，Netty 成功地找到了一种方法，可以在不妥协的情况下实现易于开发、性能、稳定性和灵活性。

## NETTY 应用

![img](https://netty.io/images/components.png)

## WHY NETTY

> **并发高**
>
> **传输快**
>
> **封装好**

#### **并发高**

想要弄清楚Netty的三个优点，必须要对IO模型、用户空间和内核空间一定的了解，

> 现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，以下解释针对linux操作系统而言，
>
> 内核空间：将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，
>
> 用户空间： 较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间

在互联网刚刚兴起时，`Java`开发人员进行网络通信一般会使用套接字编程，例如`ServerSocket`、`Socket`之类，这种模型的本质是调用系统内核提供的 `recvfrom`接口，这种模型特点便是阻塞，其返回条件是只有在有数据包到达，并且被复制到用户空间或者发生错误才会返回。

鉴于上述原因，对于每条通信链接，必须建立其独有的线程才能使程序正确的运行，但是这个线程的大部分时间都是阻塞状态，在等待数据包的到来。这一模型被称为 **阻塞IO** ，即`BIO`。在这一模型下，由于每个线程都会分配固定的资源，服务器无法维持大量线程，当并发量变高时，服务器将耗费大量资源或时间在线程切换或系统阻塞，性能急速下降。

由于`BIO`天生的缺陷，开发人员便开始对其实施优化：

> 因为`BIO`模型中的线程数量没有限制，当客户端发起请求时会频频建立线程，使服务器在各个线程之间疲于奔命，极大的降低了服务器性能。

针对上述问题，开发人员通过引入线程池来约束线程数量，当更多的请求进来时，进入排队状态，通过这种方式来减轻服务器压力。但是这样又引入了新的问题，

> 一部分客户端不能立刻连接上服务端，

这个问题的解决办法是需要内核的支持，在操作系统层面，通过修改`recvfrom`接口，如果调用该接口没有返回数据，那么立刻返回一个`EWOULDBLOCK`的错误，通过轮询的方式检查`recvfrom`接口，这种模型被称为**非阻塞IO**，即`NIO`。

这样似乎解决了之前的所有问题，但是上述两种模型都是一个线程对应一个连接，

>  有没有一种方法能够让一个线程可以监视多个连接，这样对服务器的压力也会减轻。

答案是有的 

Linux系统提供了`select`系统调用，应用可以将多个`connect`注册到同一个`select`，由`select`去遍历所有的`recvfrom`，这样一个`select`便能监听在多个`connect`上，有效的减少线程数量。这种模型被称为**多路复用**，但是这种模型下的`select`性能与`connect`数量密切相关。

> 当`connect`数量增加时，性能会急速下降

这个问题的解决办法是通过在用户空间和内核空间共享一块内容，通过构建一颗红黑树，当`recvfrom`调用有结果后，通过修改红黑树节点状态通知到`epoll`，然后`epoll`将数据拷贝到用户空间。

以上是`JAVA`网络编程中对高并发的处理，而`Netty`正是使用了这种模型，这也是其支持高并发的基础。

#### 传输快

> Netty的传输快其实也是依赖了NIO的一个特性——*零拷贝*。我们知道，Java的内存有堆内存、栈内存和字符串常量池等等，其中堆内存是占用内存空间最大的一块，也是Java对象存放的地方，一般我们的数据如果需要从IO读取到堆内存，中间需要经过Socket缓冲区，也就是说一个数据会被拷贝两次才能到达他的的终点，如果数据量大，就会造成不必要的资源浪费。
>  Netty针对这种情况，使用了NIO中的另一大特性——零拷贝，当他需要接收数据的时候，他会在堆内存之外开辟一块内存，数据就直接从IO读到了那块内存中去，在netty里面通过ByteBuf可以直接对这些数据进行直接操作，从而加快了传输速度

#### 封装好

通过代码量一看便知。



> 参考内容：
>
> ​	https://www.jianshu.com/p/b9f3f6a16911
> ​	https://segmentfault.com/a/1190000003063859
> ​	https://zhuanlan.zhihu.com/p/272891398
> ​	Netty实战
> ​	Netty权威指南  