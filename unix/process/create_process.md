## 进程的创建

### 典型创建进程事件

- 用户登陆

- 作业调度

- 提供服务

  > 进程A申请键盘，OS创建一个进程提供该项服务

- 应用请求

  > 应用自己创建

### 进程创建过程

1. OS接受进程创建请求

2. OS调用创建原语Creat

   1. 申请空白PCB，为新进程申请唯一数字标识符

   2. 分配新进程所需资源（内存、文件、设备...）

      - 资源从系统申请

      - 资源从父进程获得

        > 新进程也要提前告知父进程或者OS需求详情
        >
        > 举例：为新进程分配内存时，OS必须要知道新进程所需内存大小
        >
        > 1. 对于批处理作业，用户需在创建进程时提供所需内存大小
        > 2. 创建子进程，也要在创建进程时提供
        > 3. 交互型进程，可以申请一定的空间
        >
        > 若是新进程要共享某个已经在内存的地址空间，则必须建立相应的链接

   3. 初始化PCB

      1. 初始化标识信息，将系统分配的标识符和父进程标识符填入分配的PCB
      2. 初始化处理机状态信息，将程序计数器指向程序的入口地址
      3. 初始化处理机控制信息，将进程的状态设置为就绪状态或者[静止就绪状态](./process_conceptual_framework)，优先级通常设置成最低，除非显示声明
      4. 如果进程就绪队列可以插入新进程，就将新进程插入队列

## 进程的终止

### 典型终止进程事件

- 正常结束

  > 进程正常完成时，会在程序的最后安排一条`Half`指令，用来标识进程完成，当程序运行到该条指令，会产生中断，告知OS本进程正常完成

- 异常结束

  异常结束是指发生异常事件，导致程序无法继续运行，常见异常如下

  - 越界：访问非本进程区域内容
  - 保护异常：访问一个不允许访问的资源或者以不允许的方式访问，例如：试图去写一个只读文件
  - 非法指令：不存在的系统指令
  - 指令越界：调用不运行当前进程执行的指令
  - 运行超时：
  - 算术运算错：
  - IO异常

- 外界干预

  - 操作员或者操作系统干预进程运行状态
  - 父进程请求：父可以申请结束子进程请求，例如当子进程完成啦父进程安排的任务后，父进程申请结束子进程
  - 父进程终止：父进程终止也会终止其所有子进程

### 进程终止过程

1. 系统接受进程终止请求

2. 调用进程终止原语exit
   1. 检索PCB集合，找到对应PCB，读取进程状态
   2. 若进程处于运行状态，立即终止运行，并置调度状态为`True`
   3. 若进程存在子进程，也会立即终止所有子进程运行
   4. 将子进程所有资源返回父进程或者OS
   5. 将此PCB从其所在队列移出，等待其他程序采集信息

## 进程的阻塞与唤醒

### 典型的阻塞进程事件

- 向系统请求资源失败
- 等待某些操作的完成
- 等待数据尚未到达
- 等待新任务到达
- ...

### 进程阻塞过程

1. 阻塞事件发生

2. 当前进程调用block原语将自己阻塞

   1. 停止自身执行
   2. 更新PCB中状态为阻塞
   3. PCB插入阻塞队列

   > 如果系统中设置因不同事件而阻塞的多个阻塞队列，则将PCB插入具有相同事件的阻塞队列

   4. 重新调度其他就绪队列进程

### 进程唤醒过程

1. 阻塞进程所期待的事件发生

2. 由有关进程调用唤醒原语wakeuo，将等待此事件的进程唤醒

   > 例如，阻塞在IO事件的进程，当IO进程接受到新的数据，由IO进程唤醒因IO事件阻塞的进程

   1. 将阻塞进程从阻塞队列移出
   2. 更新阻塞进程PCB状态为就绪
   3. 将就绪状态进程插入到就绪队列

## 进程的挂起和激活

挂起是一个主动操作，其操作原语是suspend，流程如下：

1. 检查被挂起进程状态

   - 活动 -> 静止就绪
   - 阻塞 -> 静止阻塞

2. 复制PCB到指定的区域，便于用户或者父进程查看运行情况

3. 如果被挂起进程正在执行，需要调度程序重新调度其他进程执行

   

激活，激活的原语是active，OS可以使用激活原语激活指定进程，流程如下：

1. 将进程从外存掉入内存

2. 检查进程状态

   - 静止就绪 -> 活动就绪

   - 静止阻塞 -> 活动阻塞

3. 如果是抢占调度策略，则每当有静止就绪进程进入就绪队列，便要检查是否需要重新调度，即由调度程序比较活动进程与当前进程优先级，如果激活进程优先级低，则不必重新调度，反之，则立即剥夺活动进程，将处理机分配给激活线程