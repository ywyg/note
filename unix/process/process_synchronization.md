## 进程同步的概念

### 进程间的关系

- 直接相互制约

  > 例如进程A和进程B都要访问IO资源，存在显示争用关系，我们称为直接相互制约

- 间接相互制约

  > 例如进程A和进程B相互配合，A进程在缓冲区写入，由B进程读取，在A未写入时，B进程只能等待，我们称为间接相互制约

### 临界资源和临界区

**临界资源：**诸多硬件资源如打印机、磁盘等；自定义变量等

**临界区：**访问临界资源的那段代码称为临界区

### 临界区访问规则

- 空闲让进
- 忙则等待
- 有限等待：避免死等
- 让权等待：当进程不能执行临界区时，需要立即释放处理机资源，避免出现忙等状态

## 硬件同步机制

> 主要是对临界区资源进行进程互斥，即能达到进程互斥即可

### 指令实现

- 关中断

  > 在这种机制下，当进程进入临界区之前，进程关闭中断，直到完成对临界区的访问后打开中断。这样的话，在进程执行期间，其他的进程由于OS不响应中断，从而不会产生进程调度，有效的保证了互斥。
  >
  > 关中断缺点
  >
  > - 滥用关中断会造成很大的安全隐患
  > - 关中断时间过长会影响系统效率
  > - 不适用于多CPU系统

- 利用Test-and-Set指令实现互斥

  > TAS实现：设置锁为TRUE，并返回锁的旧值
  >
  > ```c
  > boolean TS(boolean *lock){
  >   boolean old;
  >   old = *lock;
  >   *lock = TEUE;
  >   return old;
  > }
  > ```
  >
  > TAS使用：当旧值为true时，循环不会停止，直到旧值为false
  >
  > ```c
  > do{
  >   while(TS(&lock));
  >   lock = FALSE;
  > }while(TRUE)
  > ```

- 利用Swap指令实现进程互斥

  > Swap指令又称为XCHG指令，用于交换两个字内容，实现如下
  >
  > ```c
  > void swap(boolean *a,boolean *b)
  > {
  >     boolean temp;
  >     temp = *a;
  >     *a = *b;
  >     *b = temp
  > }
  > ```
  >
  > 用对换指令可以简单有效的实现互斥，方法是为每个临界资源设置一个全局的布尔变量`LOCK`，其初值为false,
  >
  > 每个进程在利用一个局部布尔变量，调用Swap指令实现进程互斥，
  >
  > ```c
  > do{
  >     key = TRUE;
  >     do{
  >         swap(&lock,&key); //lock是共享，进程想要更新lock,就得把自己的key赋值进去，因为同时只能有一个进程进入设置，第二进程设置时，key返回的是TRUE,当前循环继续，直到第一个进程将lock设置成false,这种比较类似于自旋锁
  >     }while(key != FALSE)
  >         临界区资源
  >         lock = FALSE;
  >     ...
  > }while(TRUE)
  > ```

### 信号量机制

> 对于可以临界区资源，有时候也可以多个进程直接访问，但会有一个数量的限制

- 整型信号量

  > 我们假定S为资源数目的整型量，现在我们定义两个原子操作
  >
  > ```c
  > wait(S){
  >     while(S <= 0);
  >     S--;
  > }
  > ```
  >
  > ```c
  > signal(S){
  >     S++;
  > }
  > ```

- 记录型信号量
